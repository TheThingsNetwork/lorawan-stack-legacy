// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: router.proto

package ttnpb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Modulation int32

const (
	Modulation_LORA Modulation = 0
	Modulation_FSK  Modulation = 1
)

var Modulation_name = map[int32]string{
	0: "LORA",
	1: "FSK",
}

var Modulation_value = map[string]int32{
	"LORA": 0,
	"FSK":  1,
}

func (x Modulation) String() string {
	return proto.EnumName(Modulation_name, int32(x))
}

func (Modulation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{0}
}

type FrequencyPlan int32

const (
	FrequencyPlan_EU_863_870 FrequencyPlan = 0
	FrequencyPlan_US_902_928 FrequencyPlan = 1
	FrequencyPlan_CN_779_787 FrequencyPlan = 2
	FrequencyPlan_EU_433     FrequencyPlan = 3
	FrequencyPlan_AU_915_928 FrequencyPlan = 4
	FrequencyPlan_CN_470_510 FrequencyPlan = 5
	FrequencyPlan_AS_923     FrequencyPlan = 6
	FrequencyPlan_AS_920_923 FrequencyPlan = 61
	FrequencyPlan_AS_923_925 FrequencyPlan = 62
	FrequencyPlan_KR_920_923 FrequencyPlan = 7
	FrequencyPlan_IN_865_867 FrequencyPlan = 8
	FrequencyPlan_RU_864_870 FrequencyPlan = 9
)

var FrequencyPlan_name = map[int32]string{
	0:  "EU_863_870",
	1:  "US_902_928",
	2:  "CN_779_787",
	3:  "EU_433",
	4:  "AU_915_928",
	5:  "CN_470_510",
	6:  "AS_923",
	61: "AS_920_923",
	62: "AS_923_925",
	7:  "KR_920_923",
	8:  "IN_865_867",
	9:  "RU_864_870",
}

var FrequencyPlan_value = map[string]int32{
	"EU_863_870": 0,
	"US_902_928": 1,
	"CN_779_787": 2,
	"EU_433":     3,
	"AU_915_928": 4,
	"CN_470_510": 5,
	"AS_923":     6,
	"AS_920_923": 61,
	"AS_923_925": 62,
	"KR_920_923": 7,
	"IN_865_867": 8,
	"RU_864_870": 9,
}

func (x FrequencyPlan) String() string {
	return proto.EnumName(FrequencyPlan_name, int32(x))
}

func (FrequencyPlan) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{1}
}

type LocationMetadata_LocationSource int32

const (
	LocationMetadata_UNKNOWN        LocationMetadata_LocationSource = 0
	LocationMetadata_GPS            LocationMetadata_LocationSource = 1
	LocationMetadata_CONFIG         LocationMetadata_LocationSource = 2
	LocationMetadata_REGISTRY       LocationMetadata_LocationSource = 3
	LocationMetadata_IP_GEOLOCATION LocationMetadata_LocationSource = 4
)

var LocationMetadata_LocationSource_name = map[int32]string{
	0: "UNKNOWN",
	1: "GPS",
	2: "CONFIG",
	3: "REGISTRY",
	4: "IP_GEOLOCATION",
}

var LocationMetadata_LocationSource_value = map[string]int32{
	"UNKNOWN":        0,
	"GPS":            1,
	"CONFIG":         2,
	"REGISTRY":       3,
	"IP_GEOLOCATION": 4,
}

func (x LocationMetadata_LocationSource) String() string {
	return proto.EnumName(LocationMetadata_LocationSource_name, int32(x))
}

func (LocationMetadata_LocationSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{7, 0}
}

type UplinkMessage struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// ProtocolMessage message = 2;
	ProtocolMetadata     *ProtocolRxMetadata `protobuf:"bytes,11,opt,name=protocol_metadata,json=protocolMetadata,proto3" json:"protocol_metadata,omitempty"`
	GatewayMetadata      *GatewayRxMetadata  `protobuf:"bytes,12,opt,name=gateway_metadata,json=gatewayMetadata,proto3" json:"gateway_metadata,omitempty"`
	Trace                *Trace              `protobuf:"bytes,21,opt,name=trace,proto3" json:"trace,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *UplinkMessage) Reset()         { *m = UplinkMessage{} }
func (m *UplinkMessage) String() string { return proto.CompactTextString(m) }
func (*UplinkMessage) ProtoMessage()    {}
func (*UplinkMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{0}
}
func (m *UplinkMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UplinkMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UplinkMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UplinkMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UplinkMessage.Merge(m, src)
}
func (m *UplinkMessage) XXX_Size() int {
	return m.Size()
}
func (m *UplinkMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UplinkMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UplinkMessage proto.InternalMessageInfo

func (m *UplinkMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *UplinkMessage) GetProtocolMetadata() *ProtocolRxMetadata {
	if m != nil {
		return m.ProtocolMetadata
	}
	return nil
}

func (m *UplinkMessage) GetGatewayMetadata() *GatewayRxMetadata {
	if m != nil {
		return m.GatewayMetadata
	}
	return nil
}

func (m *UplinkMessage) GetTrace() *Trace {
	if m != nil {
		return m.Trace
	}
	return nil
}

type DownlinkMessage struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// ProtocolMessage message = 2;
	ProtocolConfiguration *ProtocolTxConfiguration `protobuf:"bytes,11,opt,name=protocol_configuration,json=protocolConfiguration,proto3" json:"protocol_configuration,omitempty"`
	GatewayConfiguration  *GatewayTxConfiguration  `protobuf:"bytes,12,opt,name=gateway_configuration,json=gatewayConfiguration,proto3" json:"gateway_configuration,omitempty"`
	Trace                 *Trace                   `protobuf:"bytes,21,opt,name=trace,proto3" json:"trace,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                 `json:"-"`
	XXX_unrecognized      []byte                   `json:"-"`
	XXX_sizecache         int32                    `json:"-"`
}

func (m *DownlinkMessage) Reset()         { *m = DownlinkMessage{} }
func (m *DownlinkMessage) String() string { return proto.CompactTextString(m) }
func (*DownlinkMessage) ProtoMessage()    {}
func (*DownlinkMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{1}
}
func (m *DownlinkMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownlinkMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownlinkMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownlinkMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownlinkMessage.Merge(m, src)
}
func (m *DownlinkMessage) XXX_Size() int {
	return m.Size()
}
func (m *DownlinkMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DownlinkMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DownlinkMessage proto.InternalMessageInfo

func (m *DownlinkMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *DownlinkMessage) GetProtocolConfiguration() *ProtocolTxConfiguration {
	if m != nil {
		return m.ProtocolConfiguration
	}
	return nil
}

func (m *DownlinkMessage) GetGatewayConfiguration() *GatewayTxConfiguration {
	if m != nil {
		return m.GatewayConfiguration
	}
	return nil
}

func (m *DownlinkMessage) GetTrace() *Trace {
	if m != nil {
		return m.Trace
	}
	return nil
}

type Trace struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Time                 int64             `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	ServiceId            string            `protobuf:"bytes,3,opt,name=service_id,json=serviceId,proto3" json:"service_id,omitempty"`
	ServiceName          string            `protobuf:"bytes,4,opt,name=service_name,json=serviceName,proto3" json:"service_name,omitempty"`
	Event                string            `protobuf:"bytes,5,opt,name=event,proto3" json:"event,omitempty"`
	Metadata             map[string]string `protobuf:"bytes,6,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Parents              []*Trace          `protobuf:"bytes,11,rep,name=parents,proto3" json:"parents,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Trace) Reset()         { *m = Trace{} }
func (m *Trace) String() string { return proto.CompactTextString(m) }
func (*Trace) ProtoMessage()    {}
func (*Trace) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{2}
}
func (m *Trace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trace.Merge(m, src)
}
func (m *Trace) XXX_Size() int {
	return m.Size()
}
func (m *Trace) XXX_DiscardUnknown() {
	xxx_messageInfo_Trace.DiscardUnknown(m)
}

var xxx_messageInfo_Trace proto.InternalMessageInfo

func (m *Trace) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Trace) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Trace) GetServiceId() string {
	if m != nil {
		return m.ServiceId
	}
	return ""
}

func (m *Trace) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *Trace) GetEvent() string {
	if m != nil {
		return m.Event
	}
	return ""
}

func (m *Trace) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Trace) GetParents() []*Trace {
	if m != nil {
		return m.Parents
	}
	return nil
}

type ProtocolRxMetadata struct {
	Lorawan              *LoRaWANMetadata `protobuf:"bytes,1,opt,name=lorawan,proto3" json:"lorawan,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ProtocolRxMetadata) Reset()         { *m = ProtocolRxMetadata{} }
func (m *ProtocolRxMetadata) String() string { return proto.CompactTextString(m) }
func (*ProtocolRxMetadata) ProtoMessage()    {}
func (*ProtocolRxMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{3}
}
func (m *ProtocolRxMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolRxMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolRxMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolRxMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolRxMetadata.Merge(m, src)
}
func (m *ProtocolRxMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolRxMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolRxMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolRxMetadata proto.InternalMessageInfo

func (m *ProtocolRxMetadata) GetLorawan() *LoRaWANMetadata {
	if m != nil {
		return m.Lorawan
	}
	return nil
}

type ProtocolTxConfiguration struct {
	Lorawan              *LoRaWANTxConfiguration `protobuf:"bytes,1,opt,name=lorawan,proto3" json:"lorawan,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ProtocolTxConfiguration) Reset()         { *m = ProtocolTxConfiguration{} }
func (m *ProtocolTxConfiguration) String() string { return proto.CompactTextString(m) }
func (*ProtocolTxConfiguration) ProtoMessage()    {}
func (*ProtocolTxConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{4}
}
func (m *ProtocolTxConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProtocolTxConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProtocolTxConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProtocolTxConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProtocolTxConfiguration.Merge(m, src)
}
func (m *ProtocolTxConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *ProtocolTxConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_ProtocolTxConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_ProtocolTxConfiguration proto.InternalMessageInfo

func (m *ProtocolTxConfiguration) GetLorawan() *LoRaWANTxConfiguration {
	if m != nil {
		return m.Lorawan
	}
	return nil
}

type LoRaWANMetadata struct {
	Modulation           Modulation    `protobuf:"varint,11,opt,name=modulation,proto3,enum=router.Modulation" json:"modulation,omitempty"`
	DataRate             string        `protobuf:"bytes,12,opt,name=data_rate,json=dataRate,proto3" json:"data_rate,omitempty"`
	BitRate              uint32        `protobuf:"varint,13,opt,name=bit_rate,json=bitRate,proto3" json:"bit_rate,omitempty"`
	CodingRate           string        `protobuf:"bytes,14,opt,name=coding_rate,json=codingRate,proto3" json:"coding_rate,omitempty"`
	FCnt                 uint32        `protobuf:"varint,15,opt,name=f_cnt,json=fCnt,proto3" json:"f_cnt,omitempty"`
	FrequencyPlan        FrequencyPlan `protobuf:"varint,16,opt,name=frequency_plan,json=frequencyPlan,proto3,enum=router.FrequencyPlan" json:"frequency_plan,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *LoRaWANMetadata) Reset()         { *m = LoRaWANMetadata{} }
func (m *LoRaWANMetadata) String() string { return proto.CompactTextString(m) }
func (*LoRaWANMetadata) ProtoMessage()    {}
func (*LoRaWANMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{5}
}
func (m *LoRaWANMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoRaWANMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoRaWANMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoRaWANMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoRaWANMetadata.Merge(m, src)
}
func (m *LoRaWANMetadata) XXX_Size() int {
	return m.Size()
}
func (m *LoRaWANMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_LoRaWANMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_LoRaWANMetadata proto.InternalMessageInfo

func (m *LoRaWANMetadata) GetModulation() Modulation {
	if m != nil {
		return m.Modulation
	}
	return Modulation_LORA
}

func (m *LoRaWANMetadata) GetDataRate() string {
	if m != nil {
		return m.DataRate
	}
	return ""
}

func (m *LoRaWANMetadata) GetBitRate() uint32 {
	if m != nil {
		return m.BitRate
	}
	return 0
}

func (m *LoRaWANMetadata) GetCodingRate() string {
	if m != nil {
		return m.CodingRate
	}
	return ""
}

func (m *LoRaWANMetadata) GetFCnt() uint32 {
	if m != nil {
		return m.FCnt
	}
	return 0
}

func (m *LoRaWANMetadata) GetFrequencyPlan() FrequencyPlan {
	if m != nil {
		return m.FrequencyPlan
	}
	return FrequencyPlan_EU_863_870
}

type LoRaWANTxConfiguration struct {
	Modulation           Modulation `protobuf:"varint,11,opt,name=modulation,proto3,enum=router.Modulation" json:"modulation,omitempty"`
	DataRate             string     `protobuf:"bytes,12,opt,name=data_rate,json=dataRate,proto3" json:"data_rate,omitempty"`
	BitRate              uint32     `protobuf:"varint,13,opt,name=bit_rate,json=bitRate,proto3" json:"bit_rate,omitempty"`
	CodingRate           string     `protobuf:"bytes,14,opt,name=coding_rate,json=codingRate,proto3" json:"coding_rate,omitempty"`
	FCnt                 uint32     `protobuf:"varint,15,opt,name=f_cnt,json=fCnt,proto3" json:"f_cnt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *LoRaWANTxConfiguration) Reset()         { *m = LoRaWANTxConfiguration{} }
func (m *LoRaWANTxConfiguration) String() string { return proto.CompactTextString(m) }
func (*LoRaWANTxConfiguration) ProtoMessage()    {}
func (*LoRaWANTxConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{6}
}
func (m *LoRaWANTxConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoRaWANTxConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoRaWANTxConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoRaWANTxConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoRaWANTxConfiguration.Merge(m, src)
}
func (m *LoRaWANTxConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *LoRaWANTxConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_LoRaWANTxConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_LoRaWANTxConfiguration proto.InternalMessageInfo

func (m *LoRaWANTxConfiguration) GetModulation() Modulation {
	if m != nil {
		return m.Modulation
	}
	return Modulation_LORA
}

func (m *LoRaWANTxConfiguration) GetDataRate() string {
	if m != nil {
		return m.DataRate
	}
	return ""
}

func (m *LoRaWANTxConfiguration) GetBitRate() uint32 {
	if m != nil {
		return m.BitRate
	}
	return 0
}

func (m *LoRaWANTxConfiguration) GetCodingRate() string {
	if m != nil {
		return m.CodingRate
	}
	return ""
}

func (m *LoRaWANTxConfiguration) GetFCnt() uint32 {
	if m != nil {
		return m.FCnt
	}
	return 0
}

type LocationMetadata struct {
	Time                 int64                           `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Latitude             float32                         `protobuf:"fixed32,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude            float32                         `protobuf:"fixed32,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Altitude             int32                           `protobuf:"varint,4,opt,name=altitude,proto3" json:"altitude,omitempty"`
	Accuracy             int32                           `protobuf:"varint,5,opt,name=accuracy,proto3" json:"accuracy,omitempty"`
	Source               LocationMetadata_LocationSource `protobuf:"varint,6,opt,name=source,proto3,enum=router.LocationMetadata_LocationSource" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *LocationMetadata) Reset()         { *m = LocationMetadata{} }
func (m *LocationMetadata) String() string { return proto.CompactTextString(m) }
func (*LocationMetadata) ProtoMessage()    {}
func (*LocationMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{7}
}
func (m *LocationMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LocationMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LocationMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LocationMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationMetadata.Merge(m, src)
}
func (m *LocationMetadata) XXX_Size() int {
	return m.Size()
}
func (m *LocationMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_LocationMetadata proto.InternalMessageInfo

func (m *LocationMetadata) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *LocationMetadata) GetLatitude() float32 {
	if m != nil {
		return m.Latitude
	}
	return 0
}

func (m *LocationMetadata) GetLongitude() float32 {
	if m != nil {
		return m.Longitude
	}
	return 0
}

func (m *LocationMetadata) GetAltitude() int32 {
	if m != nil {
		return m.Altitude
	}
	return 0
}

func (m *LocationMetadata) GetAccuracy() int32 {
	if m != nil {
		return m.Accuracy
	}
	return 0
}

func (m *LocationMetadata) GetSource() LocationMetadata_LocationSource {
	if m != nil {
		return m.Source
	}
	return LocationMetadata_UNKNOWN
}

type GatewayRxMetadata struct {
	GatewayId            string                       `protobuf:"bytes,1,opt,name=gateway_id,json=gatewayId,proto3" json:"gateway_id,omitempty"`
	GatewayTrusted       bool                         `protobuf:"varint,2,opt,name=gateway_trusted,json=gatewayTrusted,proto3" json:"gateway_trusted,omitempty"`
	Timestamp            uint32                       `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Time                 int64                        `protobuf:"varint,12,opt,name=time,proto3" json:"time,omitempty"`
	EncryptedTime        []byte                       `protobuf:"bytes,13,opt,name=encrypted_time,json=encryptedTime,proto3" json:"encrypted_time,omitempty"`
	RfChain              uint32                       `protobuf:"varint,21,opt,name=rf_chain,json=rfChain,proto3" json:"rf_chain,omitempty"`
	Channel              uint32                       `protobuf:"varint,22,opt,name=channel,proto3" json:"channel,omitempty"`
	Antennas             []*GatewayRxMetadata_Antenna `protobuf:"bytes,30,rep,name=antennas,proto3" json:"antennas,omitempty"`
	Frequency            uint64                       `protobuf:"varint,31,opt,name=frequency,proto3" json:"frequency,omitempty"`
	Rssi                 float32                      `protobuf:"fixed32,32,opt,name=rssi,proto3" json:"rssi,omitempty"`
	Snr                  float32                      `protobuf:"fixed32,33,opt,name=snr,proto3" json:"snr,omitempty"`
	Location             *LocationMetadata            `protobuf:"bytes,41,opt,name=location,proto3" json:"location,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *GatewayRxMetadata) Reset()         { *m = GatewayRxMetadata{} }
func (m *GatewayRxMetadata) String() string { return proto.CompactTextString(m) }
func (*GatewayRxMetadata) ProtoMessage()    {}
func (*GatewayRxMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{8}
}
func (m *GatewayRxMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayRxMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayRxMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayRxMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayRxMetadata.Merge(m, src)
}
func (m *GatewayRxMetadata) XXX_Size() int {
	return m.Size()
}
func (m *GatewayRxMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayRxMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayRxMetadata proto.InternalMessageInfo

func (m *GatewayRxMetadata) GetGatewayId() string {
	if m != nil {
		return m.GatewayId
	}
	return ""
}

func (m *GatewayRxMetadata) GetGatewayTrusted() bool {
	if m != nil {
		return m.GatewayTrusted
	}
	return false
}

func (m *GatewayRxMetadata) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GatewayRxMetadata) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *GatewayRxMetadata) GetEncryptedTime() []byte {
	if m != nil {
		return m.EncryptedTime
	}
	return nil
}

func (m *GatewayRxMetadata) GetRfChain() uint32 {
	if m != nil {
		return m.RfChain
	}
	return 0
}

func (m *GatewayRxMetadata) GetChannel() uint32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *GatewayRxMetadata) GetAntennas() []*GatewayRxMetadata_Antenna {
	if m != nil {
		return m.Antennas
	}
	return nil
}

func (m *GatewayRxMetadata) GetFrequency() uint64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *GatewayRxMetadata) GetRssi() float32 {
	if m != nil {
		return m.Rssi
	}
	return 0
}

func (m *GatewayRxMetadata) GetSnr() float32 {
	if m != nil {
		return m.Snr
	}
	return 0
}

func (m *GatewayRxMetadata) GetLocation() *LocationMetadata {
	if m != nil {
		return m.Location
	}
	return nil
}

type GatewayRxMetadata_Antenna struct {
	Antenna               uint32   `protobuf:"varint,1,opt,name=antenna,proto3" json:"antenna,omitempty"`
	Channel               uint32   `protobuf:"varint,2,opt,name=channel,proto3" json:"channel,omitempty"`
	Rssi                  float32  `protobuf:"fixed32,3,opt,name=rssi,proto3" json:"rssi,omitempty"`
	ChannelRssi           float32  `protobuf:"fixed32,5,opt,name=channel_rssi,json=channelRssi,proto3" json:"channel_rssi,omitempty"`
	RssiStandardDeviation float32  `protobuf:"fixed32,6,opt,name=rssi_standard_deviation,json=rssiStandardDeviation,proto3" json:"rssi_standard_deviation,omitempty"`
	FrequencyOffset       int64    `protobuf:"varint,7,opt,name=frequency_offset,json=frequencyOffset,proto3" json:"frequency_offset,omitempty"`
	Snr                   float32  `protobuf:"fixed32,4,opt,name=snr,proto3" json:"snr,omitempty"`
	EncryptedTime         []byte   `protobuf:"bytes,10,opt,name=encrypted_time,json=encryptedTime,proto3" json:"encrypted_time,omitempty"`
	FineTime              int64    `protobuf:"varint,11,opt,name=fine_time,json=fineTime,proto3" json:"fine_time,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *GatewayRxMetadata_Antenna) Reset()         { *m = GatewayRxMetadata_Antenna{} }
func (m *GatewayRxMetadata_Antenna) String() string { return proto.CompactTextString(m) }
func (*GatewayRxMetadata_Antenna) ProtoMessage()    {}
func (*GatewayRxMetadata_Antenna) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{8, 0}
}
func (m *GatewayRxMetadata_Antenna) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayRxMetadata_Antenna) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayRxMetadata_Antenna.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayRxMetadata_Antenna) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayRxMetadata_Antenna.Merge(m, src)
}
func (m *GatewayRxMetadata_Antenna) XXX_Size() int {
	return m.Size()
}
func (m *GatewayRxMetadata_Antenna) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayRxMetadata_Antenna.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayRxMetadata_Antenna proto.InternalMessageInfo

func (m *GatewayRxMetadata_Antenna) GetAntenna() uint32 {
	if m != nil {
		return m.Antenna
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetChannel() uint32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetRssi() float32 {
	if m != nil {
		return m.Rssi
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetChannelRssi() float32 {
	if m != nil {
		return m.ChannelRssi
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetRssiStandardDeviation() float32 {
	if m != nil {
		return m.RssiStandardDeviation
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetFrequencyOffset() int64 {
	if m != nil {
		return m.FrequencyOffset
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetSnr() float32 {
	if m != nil {
		return m.Snr
	}
	return 0
}

func (m *GatewayRxMetadata_Antenna) GetEncryptedTime() []byte {
	if m != nil {
		return m.EncryptedTime
	}
	return nil
}

func (m *GatewayRxMetadata_Antenna) GetFineTime() int64 {
	if m != nil {
		return m.FineTime
	}
	return 0
}

type GatewayTxConfiguration struct {
	Timestamp             uint32   `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	RfChain               uint32   `protobuf:"varint,21,opt,name=rf_chain,json=rfChain,proto3" json:"rf_chain,omitempty"`
	Frequency             uint64   `protobuf:"varint,22,opt,name=frequency,proto3" json:"frequency,omitempty"`
	Power                 int32    `protobuf:"varint,23,opt,name=power,proto3" json:"power,omitempty"`
	PolarizationInversion bool     `protobuf:"varint,31,opt,name=polarization_inversion,json=polarizationInversion,proto3" json:"polarization_inversion,omitempty"`
	FrequencyDeviation    uint32   `protobuf:"varint,32,opt,name=frequency_deviation,json=frequencyDeviation,proto3" json:"frequency_deviation,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *GatewayTxConfiguration) Reset()         { *m = GatewayTxConfiguration{} }
func (m *GatewayTxConfiguration) String() string { return proto.CompactTextString(m) }
func (*GatewayTxConfiguration) ProtoMessage()    {}
func (*GatewayTxConfiguration) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{9}
}
func (m *GatewayTxConfiguration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GatewayTxConfiguration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GatewayTxConfiguration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GatewayTxConfiguration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayTxConfiguration.Merge(m, src)
}
func (m *GatewayTxConfiguration) XXX_Size() int {
	return m.Size()
}
func (m *GatewayTxConfiguration) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayTxConfiguration.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayTxConfiguration proto.InternalMessageInfo

func (m *GatewayTxConfiguration) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GatewayTxConfiguration) GetRfChain() uint32 {
	if m != nil {
		return m.RfChain
	}
	return 0
}

func (m *GatewayTxConfiguration) GetFrequency() uint64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *GatewayTxConfiguration) GetPower() int32 {
	if m != nil {
		return m.Power
	}
	return 0
}

func (m *GatewayTxConfiguration) GetPolarizationInversion() bool {
	if m != nil {
		return m.PolarizationInversion
	}
	return false
}

func (m *GatewayTxConfiguration) GetFrequencyDeviation() uint32 {
	if m != nil {
		return m.FrequencyDeviation
	}
	return 0
}

type StatusMessage struct {
	Timestamp            uint32                   `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Time                 int64                    `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	GatewayTrusted       bool                     `protobuf:"varint,3,opt,name=gateway_trusted,json=gatewayTrusted,proto3" json:"gateway_trusted,omitempty"`
	BootTime             int64                    `protobuf:"varint,4,opt,name=boot_time,json=bootTime,proto3" json:"boot_time,omitempty"`
	Ip                   []string                 `protobuf:"bytes,11,rep,name=ip,proto3" json:"ip,omitempty"`
	Platform             string                   `protobuf:"bytes,12,opt,name=platform,proto3" json:"platform,omitempty"`
	ContactEmail         string                   `protobuf:"bytes,13,opt,name=contact_email,json=contactEmail,proto3" json:"contact_email,omitempty"`
	Description          string                   `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	FrequencyPlan        string                   `protobuf:"bytes,15,opt,name=frequency_plan,json=frequencyPlan,proto3" json:"frequency_plan,omitempty"`
	Bridge               string                   `protobuf:"bytes,16,opt,name=bridge,proto3" json:"bridge,omitempty"`
	Router               string                   `protobuf:"bytes,17,opt,name=router,proto3" json:"router,omitempty"`
	Fpga                 uint32                   `protobuf:"varint,18,opt,name=fpga,proto3" json:"fpga,omitempty"`
	Dsp                  uint32                   `protobuf:"varint,19,opt,name=dsp,proto3" json:"dsp,omitempty"`
	Hal                  string                   `protobuf:"bytes,20,opt,name=hal,proto3" json:"hal,omitempty"`
	Location             *LocationMetadata        `protobuf:"bytes,21,opt,name=location,proto3" json:"location,omitempty"`
	Rtt                  uint32                   `protobuf:"varint,31,opt,name=rtt,proto3" json:"rtt,omitempty"`
	RxIn                 uint32                   `protobuf:"varint,41,opt,name=rx_in,json=rxIn,proto3" json:"rx_in,omitempty"`
	RxOk                 uint32                   `protobuf:"varint,42,opt,name=rx_ok,json=rxOk,proto3" json:"rx_ok,omitempty"`
	TxIn                 uint32                   `protobuf:"varint,43,opt,name=tx_in,json=txIn,proto3" json:"tx_in,omitempty"`
	TxOk                 uint32                   `protobuf:"varint,44,opt,name=tx_ok,json=txOk,proto3" json:"tx_ok,omitempty"`
	LmOk                 uint32                   `protobuf:"varint,45,opt,name=lm_ok,json=lmOk,proto3" json:"lm_ok,omitempty"`
	LmSt                 uint32                   `protobuf:"varint,46,opt,name=lm_st,json=lmSt,proto3" json:"lm_st,omitempty"`
	LmNw                 uint32                   `protobuf:"varint,47,opt,name=lm_nw,json=lmNw,proto3" json:"lm_nw,omitempty"`
	LPps                 uint32                   `protobuf:"varint,48,opt,name=l_pps,json=lPps,proto3" json:"l_pps,omitempty"`
	Os                   *StatusMessage_OSMetrics `protobuf:"bytes,51,opt,name=os,proto3" json:"os,omitempty"`
	Messages             []string                 `protobuf:"bytes,52,rep,name=messages,proto3" json:"messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *StatusMessage) Reset()         { *m = StatusMessage{} }
func (m *StatusMessage) String() string { return proto.CompactTextString(m) }
func (*StatusMessage) ProtoMessage()    {}
func (*StatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{10}
}
func (m *StatusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusMessage.Merge(m, src)
}
func (m *StatusMessage) XXX_Size() int {
	return m.Size()
}
func (m *StatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_StatusMessage proto.InternalMessageInfo

func (m *StatusMessage) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *StatusMessage) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *StatusMessage) GetGatewayTrusted() bool {
	if m != nil {
		return m.GatewayTrusted
	}
	return false
}

func (m *StatusMessage) GetBootTime() int64 {
	if m != nil {
		return m.BootTime
	}
	return 0
}

func (m *StatusMessage) GetIp() []string {
	if m != nil {
		return m.Ip
	}
	return nil
}

func (m *StatusMessage) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *StatusMessage) GetContactEmail() string {
	if m != nil {
		return m.ContactEmail
	}
	return ""
}

func (m *StatusMessage) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *StatusMessage) GetFrequencyPlan() string {
	if m != nil {
		return m.FrequencyPlan
	}
	return ""
}

func (m *StatusMessage) GetBridge() string {
	if m != nil {
		return m.Bridge
	}
	return ""
}

func (m *StatusMessage) GetRouter() string {
	if m != nil {
		return m.Router
	}
	return ""
}

func (m *StatusMessage) GetFpga() uint32 {
	if m != nil {
		return m.Fpga
	}
	return 0
}

func (m *StatusMessage) GetDsp() uint32 {
	if m != nil {
		return m.Dsp
	}
	return 0
}

func (m *StatusMessage) GetHal() string {
	if m != nil {
		return m.Hal
	}
	return ""
}

func (m *StatusMessage) GetLocation() *LocationMetadata {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *StatusMessage) GetRtt() uint32 {
	if m != nil {
		return m.Rtt
	}
	return 0
}

func (m *StatusMessage) GetRxIn() uint32 {
	if m != nil {
		return m.RxIn
	}
	return 0
}

func (m *StatusMessage) GetRxOk() uint32 {
	if m != nil {
		return m.RxOk
	}
	return 0
}

func (m *StatusMessage) GetTxIn() uint32 {
	if m != nil {
		return m.TxIn
	}
	return 0
}

func (m *StatusMessage) GetTxOk() uint32 {
	if m != nil {
		return m.TxOk
	}
	return 0
}

func (m *StatusMessage) GetLmOk() uint32 {
	if m != nil {
		return m.LmOk
	}
	return 0
}

func (m *StatusMessage) GetLmSt() uint32 {
	if m != nil {
		return m.LmSt
	}
	return 0
}

func (m *StatusMessage) GetLmNw() uint32 {
	if m != nil {
		return m.LmNw
	}
	return 0
}

func (m *StatusMessage) GetLPps() uint32 {
	if m != nil {
		return m.LPps
	}
	return 0
}

func (m *StatusMessage) GetOs() *StatusMessage_OSMetrics {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *StatusMessage) GetMessages() []string {
	if m != nil {
		return m.Messages
	}
	return nil
}

type StatusMessage_OSMetrics struct {
	Load_1               float32  `protobuf:"fixed32,1,opt,name=load_1,json=load1,proto3" json:"load_1,omitempty"`
	Load_5               float32  `protobuf:"fixed32,2,opt,name=load_5,json=load5,proto3" json:"load_5,omitempty"`
	Load_15              float32  `protobuf:"fixed32,3,opt,name=load_15,json=load15,proto3" json:"load_15,omitempty"`
	CpuPercentage        float32  `protobuf:"fixed32,11,opt,name=cpu_percentage,json=cpuPercentage,proto3" json:"cpu_percentage,omitempty"`
	MemoryPercentage     float32  `protobuf:"fixed32,21,opt,name=memory_percentage,json=memoryPercentage,proto3" json:"memory_percentage,omitempty"`
	Temperature          float32  `protobuf:"fixed32,31,opt,name=temperature,proto3" json:"temperature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StatusMessage_OSMetrics) Reset()         { *m = StatusMessage_OSMetrics{} }
func (m *StatusMessage_OSMetrics) String() string { return proto.CompactTextString(m) }
func (*StatusMessage_OSMetrics) ProtoMessage()    {}
func (*StatusMessage_OSMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_367072455c71aedc, []int{10, 0}
}
func (m *StatusMessage_OSMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusMessage_OSMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusMessage_OSMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusMessage_OSMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusMessage_OSMetrics.Merge(m, src)
}
func (m *StatusMessage_OSMetrics) XXX_Size() int {
	return m.Size()
}
func (m *StatusMessage_OSMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusMessage_OSMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_StatusMessage_OSMetrics proto.InternalMessageInfo

func (m *StatusMessage_OSMetrics) GetLoad_1() float32 {
	if m != nil {
		return m.Load_1
	}
	return 0
}

func (m *StatusMessage_OSMetrics) GetLoad_5() float32 {
	if m != nil {
		return m.Load_5
	}
	return 0
}

func (m *StatusMessage_OSMetrics) GetLoad_15() float32 {
	if m != nil {
		return m.Load_15
	}
	return 0
}

func (m *StatusMessage_OSMetrics) GetCpuPercentage() float32 {
	if m != nil {
		return m.CpuPercentage
	}
	return 0
}

func (m *StatusMessage_OSMetrics) GetMemoryPercentage() float32 {
	if m != nil {
		return m.MemoryPercentage
	}
	return 0
}

func (m *StatusMessage_OSMetrics) GetTemperature() float32 {
	if m != nil {
		return m.Temperature
	}
	return 0
}

func init() {
	proto.RegisterEnum("router.Modulation", Modulation_name, Modulation_value)
	proto.RegisterEnum("router.FrequencyPlan", FrequencyPlan_name, FrequencyPlan_value)
	proto.RegisterEnum("router.LocationMetadata_LocationSource", LocationMetadata_LocationSource_name, LocationMetadata_LocationSource_value)
	proto.RegisterType((*UplinkMessage)(nil), "router.UplinkMessage")
	proto.RegisterType((*DownlinkMessage)(nil), "router.DownlinkMessage")
	proto.RegisterType((*Trace)(nil), "router.Trace")
	proto.RegisterMapType((map[string]string)(nil), "router.Trace.MetadataEntry")
	proto.RegisterType((*ProtocolRxMetadata)(nil), "router.ProtocolRxMetadata")
	proto.RegisterType((*ProtocolTxConfiguration)(nil), "router.ProtocolTxConfiguration")
	proto.RegisterType((*LoRaWANMetadata)(nil), "router.LoRaWANMetadata")
	proto.RegisterType((*LoRaWANTxConfiguration)(nil), "router.LoRaWANTxConfiguration")
	proto.RegisterType((*LocationMetadata)(nil), "router.LocationMetadata")
	proto.RegisterType((*GatewayRxMetadata)(nil), "router.GatewayRxMetadata")
	proto.RegisterType((*GatewayRxMetadata_Antenna)(nil), "router.GatewayRxMetadata.Antenna")
	proto.RegisterType((*GatewayTxConfiguration)(nil), "router.GatewayTxConfiguration")
	proto.RegisterType((*StatusMessage)(nil), "router.StatusMessage")
	proto.RegisterType((*StatusMessage_OSMetrics)(nil), "router.StatusMessage.OSMetrics")
}

func init() { proto.RegisterFile("router.proto", fileDescriptor_367072455c71aedc) }

var fileDescriptor_367072455c71aedc = []byte{
	// 1774 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0x5f, 0xea, 0xbf, 0x9e, 0x4c, 0x99, 0x99, 0x44, 0x36, 0x63, 0xb7, 0xb6, 0xa2, 0x45, 0x11,
	0x6f, 0xb6, 0x91, 0x6d, 0xd9, 0x8a, 0xed, 0xb6, 0xbb, 0xad, 0xeb, 0x38, 0x86, 0x90, 0x44, 0x32,
	0x46, 0x76, 0x17, 0xed, 0x85, 0x18, 0x51, 0x23, 0x99, 0x30, 0x45, 0xb2, 0xc3, 0x91, 0x6d, 0xf5,
	0x5b, 0xf4, 0x2b, 0xf4, 0x5e, 0xf4, 0xde, 0x7b, 0xd1, 0x3d, 0x16, 0xbd, 0x17, 0x28, 0x72, 0xef,
	0xa1, 0x1f, 0xa0, 0x40, 0x31, 0x33, 0x24, 0xf5, 0x27, 0x76, 0x9a, 0x63, 0x6f, 0x7c, 0xbf, 0xdf,
	0xef, 0x3d, 0xce, 0x9b, 0x79, 0xf3, 0x66, 0x06, 0x96, 0x98, 0x3f, 0xe6, 0x94, 0xd5, 0x03, 0xe6,
	0x73, 0x1f, 0xe5, 0x94, 0xb5, 0xb6, 0x3e, 0xf4, 0xfd, 0xa1, 0x4b, 0xb7, 0x25, 0xda, 0x1b, 0x0f,
	0xb6, 0xe9, 0x28, 0xe0, 0x13, 0x25, 0xaa, 0xfd, 0x43, 0x03, 0xfd, 0x32, 0x70, 0x1d, 0xef, 0xfa,
	0x3d, 0x0d, 0x43, 0x32, 0xa4, 0xc8, 0x84, 0x7c, 0x40, 0x26, 0xae, 0x4f, 0xfa, 0xa6, 0x56, 0xd5,
	0xb6, 0x96, 0x70, 0x6c, 0xa2, 0x33, 0x78, 0x24, 0x9d, 0x6c, 0xdf, 0xb5, 0x46, 0x94, 0x93, 0x3e,
	0xe1, 0xc4, 0x2c, 0x55, 0xb5, 0xad, 0x52, 0x63, 0xad, 0x1e, 0xfd, 0xfa, 0x3c, 0x12, 0xe0, 0xbb,
	0xf7, 0x91, 0x02, 0x1b, 0xb1, 0x53, 0x8c, 0xa0, 0xd7, 0x60, 0x0c, 0x09, 0xa7, 0xb7, 0x64, 0x32,
	0x8d, 0xb3, 0x24, 0xe3, 0x3c, 0x8d, 0xe3, 0x9c, 0x29, 0x7e, 0x26, 0xcc, 0x72, 0xe4, 0x92, 0x44,
	0xf9, 0x12, 0xb2, 0x9c, 0x11, 0x9b, 0x9a, 0x15, 0xe9, 0xaa, 0xc7, 0xae, 0x17, 0x02, 0xc4, 0x8a,
	0xab, 0xfd, 0x47, 0x83, 0xe5, 0xd7, 0xfe, 0xad, 0xf7, 0x79, 0x19, 0xfe, 0x0a, 0x56, 0x92, 0x0c,
	0x6d, 0xdf, 0x1b, 0x38, 0xc3, 0x31, 0x23, 0xdc, 0xf1, 0xbd, 0x28, 0xcd, 0xcd, 0xc5, 0x34, 0x2f,
	0xee, 0x4e, 0x66, 0x65, 0xb8, 0x12, 0xbb, 0xcf, 0xc1, 0xa8, 0x0b, 0x95, 0x38, 0xe1, 0xf9, 0xb0,
	0x2a, 0xeb, 0x8d, 0x85, 0xac, 0x17, 0xa3, 0x3e, 0x89, 0x9c, 0xe7, 0x83, 0x7e, 0x56, 0xfe, 0x7f,
	0x48, 0x41, 0x56, 0x02, 0xa8, 0x0c, 0x29, 0x47, 0x25, 0x5c, 0xc4, 0x29, 0xa7, 0x8f, 0x10, 0x64,
	0xb8, 0x33, 0xa2, 0x66, 0xaa, 0xaa, 0x6d, 0xa5, 0xb1, 0xfc, 0x46, 0x3f, 0x04, 0x08, 0x29, 0xbb,
	0x71, 0x6c, 0x6a, 0x39, 0x7d, 0x33, 0x2d, 0xb5, 0xc5, 0x08, 0x69, 0xf5, 0xd1, 0x33, 0x58, 0x8a,
	0x69, 0x8f, 0x8c, 0xa8, 0x99, 0x91, 0x82, 0x52, 0x84, 0xb5, 0xc9, 0x88, 0xa2, 0x27, 0x90, 0xa5,
	0x37, 0xd4, 0xe3, 0x66, 0x56, 0x72, 0xca, 0x40, 0x07, 0x50, 0x48, 0x16, 0x3a, 0x57, 0x4d, 0x6f,
	0x95, 0x1a, 0xeb, 0x73, 0xa3, 0xad, 0xc7, 0x8b, 0x7a, 0xea, 0x71, 0x36, 0xc1, 0x89, 0x18, 0x3d,
	0x17, 0x4b, 0xc5, 0xa8, 0xc7, 0x43, 0xb3, 0x24, 0xfd, 0x16, 0xb2, 0x8c, 0xd9, 0xb5, 0x9f, 0x82,
	0x3e, 0x17, 0x03, 0x19, 0x90, 0xbe, 0xa6, 0x93, 0x28, 0x5f, 0xf1, 0x29, 0x86, 0x76, 0x43, 0xdc,
	0xb1, 0xca, 0xb8, 0x88, 0x95, 0xf1, 0x93, 0xd4, 0xa1, 0x56, 0x3b, 0x03, 0xf4, 0x71, 0xdd, 0xa2,
	0x5d, 0xc8, 0xbb, 0x3e, 0x23, 0xb7, 0xc4, 0x93, 0x51, 0x4a, 0x8d, 0xd5, 0xf8, 0xdf, 0xef, 0x7c,
	0x4c, 0xbe, 0x3b, 0x6e, 0x27, 0xa5, 0x19, 0xeb, 0x6a, 0x5d, 0x58, 0x7d, 0xa0, 0x32, 0xd0, 0xe1,
	0x62, 0xb4, 0x8d, 0x85, 0x68, 0x8b, 0x8b, 0x9e, 0x04, 0xfd, 0xb7, 0x06, 0xcb, 0x0b, 0x7f, 0x44,
	0x0d, 0x80, 0x91, 0xdf, 0x1f, 0xbb, 0xd3, 0xe2, 0x2c, 0x37, 0x50, 0x1c, 0xf0, 0x7d, 0xc2, 0xe0,
	0x19, 0x15, 0x5a, 0x87, 0xa2, 0xf0, 0xb5, 0x18, 0xe1, 0x54, 0x16, 0x5e, 0x11, 0x17, 0xe4, 0xf0,
	0x09, 0xa7, 0xe8, 0x29, 0x14, 0x7a, 0x0e, 0x57, 0x9c, 0x5e, 0xd5, 0xb6, 0x74, 0x9c, 0xef, 0x39,
	0x5c, 0x52, 0x9b, 0x50, 0xb2, 0xfd, 0xbe, 0xe3, 0x0d, 0x15, 0x5b, 0x96, 0x9e, 0xa0, 0x20, 0x29,
	0x78, 0x0c, 0xd9, 0x81, 0x65, 0x7b, 0xdc, 0x5c, 0x96, 0x8e, 0x99, 0xc1, 0x89, 0xc7, 0xd1, 0xcf,
	0xa0, 0x3c, 0x60, 0xf4, 0xb7, 0x63, 0xea, 0xd9, 0x13, 0x2b, 0x70, 0x89, 0x67, 0x1a, 0x72, 0x94,
	0x95, 0x78, 0x94, 0x6f, 0x62, 0xf6, 0xdc, 0x25, 0x1e, 0xd6, 0x07, 0xb3, 0x66, 0xed, 0xcf, 0x1a,
	0xac, 0xdc, 0x3f, 0x2f, 0xff, 0xff, 0xa9, 0xd7, 0xfe, 0x94, 0x02, 0xe3, 0x9d, 0x6f, 0xcb, 0x5f,
	0x27, 0x2b, 0x16, 0x6f, 0x37, 0x6d, 0x66, 0xbb, 0xad, 0x41, 0x41, 0x0c, 0x90, 0x8f, 0xfb, 0xaa,
	0x28, 0x53, 0x38, 0xb1, 0xd1, 0x0f, 0xa0, 0xe8, 0xfa, 0xde, 0x50, 0x91, 0x69, 0x49, 0x4e, 0x01,
	0xe1, 0x49, 0xdc, 0xc8, 0x53, 0xec, 0xc2, 0x2c, 0x4e, 0x6c, 0xc9, 0xd9, 0xf6, 0x98, 0x11, 0x7b,
	0x22, 0x77, 0xa1, 0xe0, 0x22, 0x1b, 0xfd, 0x1c, 0x72, 0xa1, 0x3f, 0x66, 0x36, 0x35, 0x73, 0x72,
	0xe2, 0x9e, 0x4f, 0x8b, 0x70, 0x7e, 0xbc, 0x09, 0xd0, 0x95, 0x72, 0x1c, 0xb9, 0xd5, 0x2e, 0xa0,
	0x3c, 0xcf, 0xa0, 0x12, 0xe4, 0x2f, 0xdb, 0x6f, 0xdb, 0x9d, 0xef, 0xda, 0xc6, 0x17, 0x28, 0x0f,
	0xe9, 0xb3, 0xf3, 0xae, 0xa1, 0x21, 0x80, 0xdc, 0x49, 0xa7, 0xfd, 0xa6, 0x75, 0x66, 0xa4, 0xd0,
	0x12, 0x14, 0xf0, 0xe9, 0x59, 0xab, 0x7b, 0x81, 0x7f, 0x6d, 0xa4, 0x11, 0x82, 0x72, 0xeb, 0xdc,
	0x3a, 0x3b, 0xed, 0xbc, 0xeb, 0x9c, 0x1c, 0x5f, 0xb4, 0x3a, 0x6d, 0x23, 0x53, 0xfb, 0x7b, 0x16,
	0x1e, 0x7d, 0xd4, 0xf1, 0x45, 0x37, 0x8a, 0xbb, 0x66, 0xd2, 0xb9, 0x8a, 0x11, 0xd2, 0xea, 0xa3,
	0xe7, 0x10, 0x1f, 0x09, 0x16, 0x67, 0xe3, 0x90, 0xd3, 0xbe, 0x9c, 0xc4, 0x02, 0x2e, 0x47, 0xf0,
	0x85, 0x42, 0xc5, 0x54, 0x8a, 0xe9, 0x0e, 0x39, 0x19, 0x05, 0xb2, 0x60, 0x74, 0x3c, 0x05, 0x92,
	0x85, 0x59, 0x9a, 0x59, 0x98, 0x1f, 0x41, 0x99, 0x7a, 0x36, 0x9b, 0x04, 0x9c, 0xf6, 0x2d, 0xc9,
	0xea, 0xf2, 0xa0, 0xd0, 0x13, 0xf4, 0x42, 0xc8, 0x9e, 0x42, 0x81, 0x0d, 0x2c, 0xfb, 0x8a, 0x38,
	0x9e, 0x6c, 0xc2, 0x3a, 0xce, 0xb3, 0xc1, 0x89, 0x30, 0xc5, 0x19, 0x63, 0x5f, 0x11, 0xcf, 0xa3,
	0xae, 0xb9, 0xa2, 0x98, 0xc8, 0x44, 0xdf, 0x40, 0x81, 0x78, 0x9c, 0x7a, 0x1e, 0x09, 0xcd, 0x0d,
	0xd9, 0xd3, 0x9e, 0x3d, 0x78, 0xe8, 0xd5, 0x8f, 0x95, 0x12, 0x27, 0x2e, 0x22, 0x99, 0x64, 0xab,
	0x98, 0x9b, 0x55, 0x6d, 0x2b, 0x83, 0xa7, 0x80, 0x48, 0x86, 0x85, 0xa1, 0x63, 0x56, 0x65, 0xc1,
	0xc8, 0x6f, 0xd1, 0x09, 0x43, 0x8f, 0x99, 0xcf, 0x24, 0x24, 0x3e, 0xd1, 0x3e, 0x14, 0xdc, 0x68,
	0x11, 0xcd, 0xaf, 0x64, 0x33, 0x32, 0x1f, 0xaa, 0x03, 0x9c, 0x28, 0xd7, 0xfe, 0x98, 0x82, 0x7c,
	0x34, 0x1e, 0x91, 0x5e, 0x34, 0x22, 0xb9, 0x2e, 0x3a, 0x8e, 0xcd, 0xd9, 0xc4, 0x53, 0xf3, 0x89,
	0xc7, 0x63, 0x4b, 0xcf, 0x8c, 0xed, 0x19, 0x2c, 0x45, 0xb4, 0x25, 0xb9, 0xac, 0xe4, 0x4a, 0x11,
	0x86, 0x85, 0xe4, 0x15, 0xac, 0x0a, 0xca, 0x0a, 0x39, 0xf1, 0xfa, 0x84, 0xf5, 0xad, 0x3e, 0xbd,
	0x71, 0xd4, 0xd8, 0x73, 0x52, 0x5d, 0x11, 0x74, 0x37, 0x62, 0x5f, 0xc7, 0x24, 0xfa, 0x0a, 0x8c,
	0x69, 0x03, 0xf2, 0x07, 0x83, 0x90, 0x72, 0x33, 0x2f, 0xd7, 0x78, 0x39, 0xc1, 0x3b, 0x12, 0x8e,
	0x67, 0x28, 0x33, 0x9d, 0xa1, 0x8f, 0x0b, 0x00, 0xee, 0x2b, 0x80, 0x75, 0x28, 0x0e, 0x1c, 0x8f,
	0x2a, 0x45, 0x49, 0x06, 0x2f, 0x08, 0x40, 0x90, 0xb5, 0x7f, 0x69, 0xb0, 0x72, 0xff, 0x81, 0xfe,
	0x3f, 0x2a, 0xf2, 0x13, 0x65, 0x35, 0xb7, 0xfa, 0x2b, 0x8b, 0xab, 0xff, 0x04, 0xb2, 0x81, 0x7f,
	0x4b, 0x99, 0xb9, 0x2a, 0xb7, 0xbd, 0x32, 0x50, 0x13, 0x56, 0x02, 0xdf, 0x25, 0xcc, 0xf9, 0x9d,
	0xfc, 0xb9, 0xe5, 0x78, 0x37, 0x94, 0x85, 0x62, 0xfe, 0x36, 0xe5, 0x76, 0xa9, 0xcc, 0xb2, 0xad,
	0x98, 0x44, 0xdb, 0xf0, 0x78, 0x3a, 0x7f, 0xd3, 0x39, 0xaf, 0xca, 0x01, 0xa1, 0x84, 0x4a, 0x26,
	0xbc, 0xf6, 0xfb, 0x3c, 0xe8, 0x5d, 0x4e, 0xf8, 0x38, 0x8c, 0x2f, 0x5a, 0x73, 0x69, 0x6a, 0x0f,
	0x6d, 0xbc, 0xd9, 0x0b, 0xc8, 0x3d, 0x7b, 0x3a, 0x7d, 0xef, 0x9e, 0x5e, 0x87, 0x62, 0xcf, 0xf7,
	0xb9, 0x9a, 0xf9, 0x8c, 0x9a, 0x79, 0x01, 0xc8, 0x65, 0x11, 0x57, 0x9d, 0x40, 0x5e, 0x18, 0xc4,
	0x55, 0x27, 0x10, 0x1d, 0x31, 0x70, 0x09, 0x1f, 0xf8, 0x6c, 0x14, 0x77, 0xff, 0xd8, 0x46, 0x5f,
	0x82, 0x6e, 0xfb, 0x1e, 0x27, 0x36, 0xb7, 0xe8, 0x88, 0x38, 0xae, 0xdc, 0xe9, 0x45, 0xbc, 0x14,
	0x81, 0xa7, 0x02, 0x43, 0x55, 0x28, 0xf5, 0x69, 0x68, 0x33, 0x27, 0x90, 0x73, 0xa0, 0xce, 0x81,
	0x59, 0x48, 0x14, 0xcc, 0xc2, 0x71, 0xb7, 0x2c, 0x45, 0xf3, 0xe7, 0x1a, 0x5a, 0x81, 0x5c, 0x8f,
	0x39, 0xfd, 0x21, 0x95, 0xa7, 0x61, 0x11, 0x47, 0x96, 0xc0, 0xd5, 0x06, 0x34, 0x1f, 0x29, 0x5c,
	0x59, 0x62, 0x8e, 0x06, 0xc1, 0x90, 0x98, 0x28, 0x3a, 0x5e, 0x82, 0x21, 0x11, 0xd5, 0xda, 0x0f,
	0x03, 0xf3, 0xb1, 0x84, 0xc4, 0xa7, 0x40, 0xae, 0x88, 0x6b, 0x3e, 0x51, 0x77, 0x9d, 0x2b, 0xe2,
	0xce, 0xed, 0xf0, 0xca, 0xe7, 0xee, 0x70, 0x11, 0x87, 0x71, 0x2e, 0xcb, 0x42, 0xc7, 0xe2, 0x53,
	0x9c, 0x6f, 0xec, 0xce, 0x72, 0x54, 0x9b, 0xd0, 0x71, 0x86, 0xdd, 0xb5, 0xbc, 0x08, 0xf4, 0xaf,
	0xcd, 0x17, 0x31, 0xd8, 0xb9, 0x16, 0x20, 0x97, 0xca, 0xaf, 0x15, 0xc8, 0x23, 0x25, 0x97, 0xca,
	0x1f, 0xc7, 0xa0, 0x52, 0xba, 0x23, 0x01, 0xbe, 0x54, 0xa0, 0x3b, 0x4a, 0xc0, 0x90, 0x9b, 0xf5,
	0x18, 0xec, 0xf2, 0x08, 0xf4, 0x6e, 0xcd, 0xed, 0x18, 0x6c, 0xdf, 0x4a, 0xd0, 0x0a, 0x82, 0xd0,
	0xdc, 0x89, 0xc0, 0xf3, 0x20, 0x44, 0xdb, 0x90, 0xf2, 0x43, 0x73, 0x6f, 0xfe, 0x92, 0x3e, 0x57,
	0x8c, 0xf5, 0x4e, 0xf7, 0x3d, 0xe5, 0xcc, 0xb1, 0x43, 0x9c, 0xf2, 0x43, 0x51, 0x12, 0x23, 0x45,
	0x84, 0xe6, 0xbe, 0x2c, 0x94, 0xc4, 0x5e, 0xfb, 0x5e, 0x83, 0x62, 0xa2, 0x46, 0x15, 0xc8, 0x89,
	0xb7, 0x81, 0xb5, 0x2b, 0x2b, 0x38, 0x85, 0xb3, 0xc2, 0xda, 0x4d, 0xe0, 0x66, 0x74, 0x72, 0x4b,
	0xb8, 0x89, 0x56, 0xc5, 0x35, 0x4f, 0xa8, 0x9b, 0x51, 0x9f, 0x93, 0xaa, 0xdd, 0xa6, 0x28, 0x10,
	0x3b, 0x18, 0x5b, 0x01, 0x65, 0x36, 0xf5, 0x38, 0x19, 0xaa, 0x7e, 0x91, 0xc2, 0xba, 0x1d, 0x8c,
	0xcf, 0x13, 0x10, 0x7d, 0x0d, 0x8f, 0x46, 0x74, 0xe4, 0xb3, 0xc9, 0xac, 0xb2, 0x22, 0x95, 0x86,
	0x22, 0x66, 0xc4, 0x55, 0x28, 0x71, 0x3a, 0x0a, 0x28, 0x23, 0x7c, 0xcc, 0xa8, 0x5c, 0xb7, 0x14,
	0x9e, 0x85, 0x5e, 0x6c, 0x02, 0x4c, 0xaf, 0x44, 0xa8, 0x00, 0x99, 0x77, 0x1d, 0x7c, 0xac, 0xce,
	0xe9, 0x37, 0xdd, 0xb7, 0x86, 0xf6, 0xe2, 0xaf, 0x1a, 0xe8, 0x73, 0x37, 0x31, 0x54, 0x06, 0x38,
	0xbd, 0xb4, 0x0e, 0x5f, 0xed, 0x59, 0x87, 0x07, 0x3b, 0xc6, 0x17, 0xc2, 0xbe, 0xec, 0x5a, 0x47,
	0x3b, 0x0d, 0xeb, 0xa8, 0x71, 0x68, 0x68, 0xc2, 0x3e, 0x69, 0x5b, 0x07, 0x07, 0x47, 0xd6, 0xc1,
	0xe1, 0x81, 0x91, 0x12, 0x27, 0xfd, 0xe9, 0xa5, 0xb5, 0xbf, 0xb7, 0x67, 0xa4, 0x05, 0x77, 0x7c,
	0x69, 0x1d, 0xed, 0x36, 0xa5, 0x36, 0x13, 0x69, 0xf7, 0x0f, 0x76, 0xac, 0xe6, 0xee, 0x8e, 0x91,
	0x15, 0xda, 0xe3, 0xae, 0x75, 0xd4, 0xd8, 0x33, 0x72, 0x52, 0x2b, 0xbe, 0x77, 0xa4, 0xfd, 0x4d,
	0x62, 0xef, 0x59, 0x47, 0x8d, 0xa6, 0xf1, 0xad, 0xb0, 0xdf, 0xe2, 0x84, 0xcf, 0x0b, 0xbb, 0xd5,
	0xb6, 0x0e, 0x5f, 0x35, 0xad, 0xc3, 0x57, 0x07, 0x46, 0x41, 0xd8, 0x58, 0x8c, 0x73, 0x5f, 0x8e,
	0xb3, 0xd8, 0xf8, 0x8b, 0x06, 0x39, 0xac, 0x76, 0xcd, 0x2f, 0x40, 0x8f, 0x1a, 0xaf, 0x2a, 0x01,
	0x54, 0xb9, 0xb7, 0x24, 0xd6, 0x56, 0xea, 0xea, 0x69, 0x5c, 0x8f, 0x9f, 0xc6, 0xf5, 0x53, 0xf1,
	0x34, 0xde, 0xd2, 0xd0, 0x11, 0xe4, 0xd4, 0xab, 0x78, 0xea, 0x3a, 0xf7, 0x4a, 0xfe, 0x84, 0xeb,
	0xb7, 0x50, 0xec, 0x8e, 0x7b, 0xa2, 0x33, 0xf4, 0x28, 0x7a, 0x40, 0xb6, 0x96, 0x3c, 0x25, 0x16,
	0xde, 0xa6, 0x3b, 0xda, 0x2f, 0x8f, 0xbf, 0xff, 0xb0, 0xa1, 0xfd, 0xed, 0xc3, 0x86, 0xf6, 0xcf,
	0x0f, 0x1b, 0xda, 0x6f, 0xf6, 0x86, 0x7e, 0x9d, 0x5f, 0x51, 0x7e, 0xe5, 0x78, 0xc3, 0xb0, 0xee,
	0x51, 0x7e, 0xeb, 0xb3, 0xeb, 0xed, 0xe8, 0x69, 0xf0, 0x32, 0xe4, 0xc4, 0xbe, 0x7e, 0xe9, 0xd2,
	0x21, 0xb1, 0x27, 0xdb, 0xc1, 0xf5, 0x70, 0x9b, 0x73, 0x2f, 0xe8, 0xf5, 0x72, 0xf2, 0x6f, 0x7b,
	0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xcf, 0x81, 0x19, 0x96, 0x10, 0x10, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RouterClient is the client API for Router service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RouterClient interface {
	GatewayStatus(ctx context.Context, opts ...grpc.CallOption) (Router_GatewayStatusClient, error)
	Uplink(ctx context.Context, opts ...grpc.CallOption) (Router_UplinkClient, error)
	Subscribe(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (Router_SubscribeClient, error)
}

type routerClient struct {
	cc *grpc.ClientConn
}

func NewRouterClient(cc *grpc.ClientConn) RouterClient {
	return &routerClient{cc}
}

func (c *routerClient) GatewayStatus(ctx context.Context, opts ...grpc.CallOption) (Router_GatewayStatusClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Router_serviceDesc.Streams[0], "/router.Router/GatewayStatus", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerGatewayStatusClient{stream}
	return x, nil
}

type Router_GatewayStatusClient interface {
	Send(*StatusMessage) error
	CloseAndRecv() (*types.Empty, error)
	grpc.ClientStream
}

type routerGatewayStatusClient struct {
	grpc.ClientStream
}

func (x *routerGatewayStatusClient) Send(m *StatusMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routerGatewayStatusClient) CloseAndRecv() (*types.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(types.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routerClient) Uplink(ctx context.Context, opts ...grpc.CallOption) (Router_UplinkClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Router_serviceDesc.Streams[1], "/router.Router/Uplink", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerUplinkClient{stream}
	return x, nil
}

type Router_UplinkClient interface {
	Send(*UplinkMessage) error
	CloseAndRecv() (*types.Empty, error)
	grpc.ClientStream
}

type routerUplinkClient struct {
	grpc.ClientStream
}

func (x *routerUplinkClient) Send(m *UplinkMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *routerUplinkClient) CloseAndRecv() (*types.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(types.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *routerClient) Subscribe(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (Router_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Router_serviceDesc.Streams[2], "/router.Router/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &routerSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Router_SubscribeClient interface {
	Recv() (*DownlinkMessage, error)
	grpc.ClientStream
}

type routerSubscribeClient struct {
	grpc.ClientStream
}

func (x *routerSubscribeClient) Recv() (*DownlinkMessage, error) {
	m := new(DownlinkMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RouterServer is the server API for Router service.
type RouterServer interface {
	GatewayStatus(Router_GatewayStatusServer) error
	Uplink(Router_UplinkServer) error
	Subscribe(*types.Empty, Router_SubscribeServer) error
}

// UnimplementedRouterServer can be embedded to have forward compatible implementations.
type UnimplementedRouterServer struct {
}

func (*UnimplementedRouterServer) GatewayStatus(srv Router_GatewayStatusServer) error {
	return status.Errorf(codes.Unimplemented, "method GatewayStatus not implemented")
}
func (*UnimplementedRouterServer) Uplink(srv Router_UplinkServer) error {
	return status.Errorf(codes.Unimplemented, "method Uplink not implemented")
}
func (*UnimplementedRouterServer) Subscribe(req *types.Empty, srv Router_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func RegisterRouterServer(s *grpc.Server, srv RouterServer) {
	s.RegisterService(&_Router_serviceDesc, srv)
}

func _Router_GatewayStatus_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouterServer).GatewayStatus(&routerGatewayStatusServer{stream})
}

type Router_GatewayStatusServer interface {
	SendAndClose(*types.Empty) error
	Recv() (*StatusMessage, error)
	grpc.ServerStream
}

type routerGatewayStatusServer struct {
	grpc.ServerStream
}

func (x *routerGatewayStatusServer) SendAndClose(m *types.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routerGatewayStatusServer) Recv() (*StatusMessage, error) {
	m := new(StatusMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Router_Uplink_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RouterServer).Uplink(&routerUplinkServer{stream})
}

type Router_UplinkServer interface {
	SendAndClose(*types.Empty) error
	Recv() (*UplinkMessage, error)
	grpc.ServerStream
}

type routerUplinkServer struct {
	grpc.ServerStream
}

func (x *routerUplinkServer) SendAndClose(m *types.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *routerUplinkServer) Recv() (*UplinkMessage, error) {
	m := new(UplinkMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Router_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(types.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RouterServer).Subscribe(m, &routerSubscribeServer{stream})
}

type Router_SubscribeServer interface {
	Send(*DownlinkMessage) error
	grpc.ServerStream
}

type routerSubscribeServer struct {
	grpc.ServerStream
}

func (x *routerSubscribeServer) Send(m *DownlinkMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _Router_serviceDesc = grpc.ServiceDesc{
	ServiceName: "router.Router",
	HandlerType: (*RouterServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GatewayStatus",
			Handler:       _Router_GatewayStatus_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Uplink",
			Handler:       _Router_Uplink_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _Router_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "router.proto",
}

func (m *UplinkMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UplinkMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UplinkMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Trace != nil {
		{
			size, err := m.Trace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.GatewayMetadata != nil {
		{
			size, err := m.GatewayMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.ProtocolMetadata != nil {
		{
			size, err := m.ProtocolMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DownlinkMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownlinkMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DownlinkMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Trace != nil {
		{
			size, err := m.Trace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.GatewayConfiguration != nil {
		{
			size, err := m.GatewayConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.ProtocolConfiguration != nil {
		{
			size, err := m.ProtocolConfiguration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Trace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Parents) > 0 {
		for iNdEx := len(m.Parents) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRouter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintRouter(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRouter(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRouter(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Event) > 0 {
		i -= len(m.Event)
		copy(dAtA[i:], m.Event)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.Event)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ServiceName) > 0 {
		i -= len(m.ServiceName)
		copy(dAtA[i:], m.ServiceName)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.ServiceName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServiceId) > 0 {
		i -= len(m.ServiceId)
		copy(dAtA[i:], m.ServiceId)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.ServiceId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Time != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolRxMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolRxMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolRxMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lorawan != nil {
		{
			size, err := m.Lorawan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProtocolTxConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProtocolTxConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProtocolTxConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lorawan != nil {
		{
			size, err := m.Lorawan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoRaWANMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoRaWANMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoRaWANMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FrequencyPlan != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.FrequencyPlan))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.FCnt != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.FCnt))
		i--
		dAtA[i] = 0x78
	}
	if len(m.CodingRate) > 0 {
		i -= len(m.CodingRate)
		copy(dAtA[i:], m.CodingRate)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.CodingRate)))
		i--
		dAtA[i] = 0x72
	}
	if m.BitRate != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.BitRate))
		i--
		dAtA[i] = 0x68
	}
	if len(m.DataRate) > 0 {
		i -= len(m.DataRate)
		copy(dAtA[i:], m.DataRate)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.DataRate)))
		i--
		dAtA[i] = 0x62
	}
	if m.Modulation != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Modulation))
		i--
		dAtA[i] = 0x58
	}
	return len(dAtA) - i, nil
}

func (m *LoRaWANTxConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoRaWANTxConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoRaWANTxConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FCnt != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.FCnt))
		i--
		dAtA[i] = 0x78
	}
	if len(m.CodingRate) > 0 {
		i -= len(m.CodingRate)
		copy(dAtA[i:], m.CodingRate)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.CodingRate)))
		i--
		dAtA[i] = 0x72
	}
	if m.BitRate != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.BitRate))
		i--
		dAtA[i] = 0x68
	}
	if len(m.DataRate) > 0 {
		i -= len(m.DataRate)
		copy(dAtA[i:], m.DataRate)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.DataRate)))
		i--
		dAtA[i] = 0x62
	}
	if m.Modulation != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Modulation))
		i--
		dAtA[i] = 0x58
	}
	return len(dAtA) - i, nil
}

func (m *LocationMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocationMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LocationMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Source != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x30
	}
	if m.Accuracy != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Accuracy))
		i--
		dAtA[i] = 0x28
	}
	if m.Altitude != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Altitude))
		i--
		dAtA[i] = 0x20
	}
	if m.Longitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Longitude))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Latitude != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Latitude))))
		i--
		dAtA[i] = 0x15
	}
	if m.Time != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GatewayRxMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayRxMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GatewayRxMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	if m.Snr != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Snr))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8d
	}
	if m.Rssi != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rssi))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x85
	}
	if m.Frequency != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Frequency))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if len(m.Antennas) > 0 {
		for iNdEx := len(m.Antennas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Antennas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRouter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xf2
		}
	}
	if m.Channel != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.RfChain != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.RfChain))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.EncryptedTime) > 0 {
		i -= len(m.EncryptedTime)
		copy(dAtA[i:], m.EncryptedTime)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.EncryptedTime)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Time != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x60
	}
	if m.Timestamp != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x58
	}
	if m.GatewayTrusted {
		i--
		if m.GatewayTrusted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.GatewayId) > 0 {
		i -= len(m.GatewayId)
		copy(dAtA[i:], m.GatewayId)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.GatewayId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GatewayRxMetadata_Antenna) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayRxMetadata_Antenna) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GatewayRxMetadata_Antenna) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FineTime != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.FineTime))
		i--
		dAtA[i] = 0x58
	}
	if len(m.EncryptedTime) > 0 {
		i -= len(m.EncryptedTime)
		copy(dAtA[i:], m.EncryptedTime)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.EncryptedTime)))
		i--
		dAtA[i] = 0x52
	}
	if m.FrequencyOffset != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.FrequencyOffset))
		i--
		dAtA[i] = 0x38
	}
	if m.RssiStandardDeviation != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RssiStandardDeviation))))
		i--
		dAtA[i] = 0x35
	}
	if m.ChannelRssi != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ChannelRssi))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Snr != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Snr))))
		i--
		dAtA[i] = 0x25
	}
	if m.Rssi != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Rssi))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Channel != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x10
	}
	if m.Antenna != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Antenna))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GatewayTxConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayTxConfiguration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GatewayTxConfiguration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FrequencyDeviation != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.FrequencyDeviation))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.PolarizationInversion {
		i--
		if m.PolarizationInversion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.Power != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Power))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.Frequency != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Frequency))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.RfChain != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.RfChain))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Timestamp != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x58
	}
	return len(dAtA) - i, nil
}

func (m *StatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Messages) > 0 {
		for iNdEx := len(m.Messages) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Messages[iNdEx])
			copy(dAtA[i:], m.Messages[iNdEx])
			i = encodeVarintRouter(dAtA, i, uint64(len(m.Messages[iNdEx])))
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.Os != nil {
		{
			size, err := m.Os.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x9a
	}
	if m.LPps != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.LPps))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.LmNw != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.LmNw))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.LmSt != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.LmSt))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.LmOk != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.LmOk))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if m.TxOk != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.TxOk))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe0
	}
	if m.TxIn != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.TxIn))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.RxOk != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.RxOk))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.RxIn != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.RxIn))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.Rtt != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Rtt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRouter(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.Hal) > 0 {
		i -= len(m.Hal)
		copy(dAtA[i:], m.Hal)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.Hal)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Dsp != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Dsp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Fpga != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Fpga))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.Router) > 0 {
		i -= len(m.Router)
		copy(dAtA[i:], m.Router)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.Router)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Bridge) > 0 {
		i -= len(m.Bridge)
		copy(dAtA[i:], m.Bridge)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.Bridge)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.FrequencyPlan) > 0 {
		i -= len(m.FrequencyPlan)
		copy(dAtA[i:], m.FrequencyPlan)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.FrequencyPlan)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ContactEmail) > 0 {
		i -= len(m.ContactEmail)
		copy(dAtA[i:], m.ContactEmail)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.ContactEmail)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintRouter(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Ip) > 0 {
		for iNdEx := len(m.Ip) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ip[iNdEx])
			copy(dAtA[i:], m.Ip[iNdEx])
			i = encodeVarintRouter(dAtA, i, uint64(len(m.Ip[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.BootTime != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.BootTime))
		i--
		dAtA[i] = 0x20
	}
	if m.GatewayTrusted {
		i--
		if m.GatewayTrusted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Time != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Timestamp != 0 {
		i = encodeVarintRouter(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatusMessage_OSMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusMessage_OSMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusMessage_OSMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Temperature != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Temperature))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfd
	}
	if m.MemoryPercentage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MemoryPercentage))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xad
	}
	if m.CpuPercentage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CpuPercentage))))
		i--
		dAtA[i] = 0x5d
	}
	if m.Load_15 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Load_15))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Load_5 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Load_5))))
		i--
		dAtA[i] = 0x15
	}
	if m.Load_1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Load_1))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func encodeVarintRouter(dAtA []byte, offset int, v uint64) int {
	offset -= sovRouter(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UplinkMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.ProtocolMetadata != nil {
		l = m.ProtocolMetadata.Size()
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.GatewayMetadata != nil {
		l = m.GatewayMetadata.Size()
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.Trace != nil {
		l = m.Trace.Size()
		n += 2 + l + sovRouter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownlinkMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.ProtocolConfiguration != nil {
		l = m.ProtocolConfiguration.Size()
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.GatewayConfiguration != nil {
		l = m.GatewayConfiguration.Size()
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.Trace != nil {
		l = m.Trace.Size()
		n += 2 + l + sovRouter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Trace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovRouter(uint64(m.Time))
	}
	l = len(m.ServiceId)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	l = len(m.Event)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovRouter(uint64(len(k))) + 1 + len(v) + sovRouter(uint64(len(v)))
			n += mapEntrySize + 1 + sovRouter(uint64(mapEntrySize))
		}
	}
	if len(m.Parents) > 0 {
		for _, e := range m.Parents {
			l = e.Size()
			n += 1 + l + sovRouter(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProtocolRxMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lorawan != nil {
		l = m.Lorawan.Size()
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProtocolTxConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lorawan != nil {
		l = m.Lorawan.Size()
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoRaWANMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Modulation != 0 {
		n += 1 + sovRouter(uint64(m.Modulation))
	}
	l = len(m.DataRate)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.BitRate != 0 {
		n += 1 + sovRouter(uint64(m.BitRate))
	}
	l = len(m.CodingRate)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.FCnt != 0 {
		n += 1 + sovRouter(uint64(m.FCnt))
	}
	if m.FrequencyPlan != 0 {
		n += 2 + sovRouter(uint64(m.FrequencyPlan))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoRaWANTxConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Modulation != 0 {
		n += 1 + sovRouter(uint64(m.Modulation))
	}
	l = len(m.DataRate)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.BitRate != 0 {
		n += 1 + sovRouter(uint64(m.BitRate))
	}
	l = len(m.CodingRate)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.FCnt != 0 {
		n += 1 + sovRouter(uint64(m.FCnt))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocationMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovRouter(uint64(m.Time))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.Altitude != 0 {
		n += 1 + sovRouter(uint64(m.Altitude))
	}
	if m.Accuracy != 0 {
		n += 1 + sovRouter(uint64(m.Accuracy))
	}
	if m.Source != 0 {
		n += 1 + sovRouter(uint64(m.Source))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewayRxMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GatewayId)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.GatewayTrusted {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovRouter(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovRouter(uint64(m.Time))
	}
	l = len(m.EncryptedTime)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.RfChain != 0 {
		n += 2 + sovRouter(uint64(m.RfChain))
	}
	if m.Channel != 0 {
		n += 2 + sovRouter(uint64(m.Channel))
	}
	if len(m.Antennas) > 0 {
		for _, e := range m.Antennas {
			l = e.Size()
			n += 2 + l + sovRouter(uint64(l))
		}
	}
	if m.Frequency != 0 {
		n += 2 + sovRouter(uint64(m.Frequency))
	}
	if m.Rssi != 0 {
		n += 6
	}
	if m.Snr != 0 {
		n += 6
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovRouter(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewayRxMetadata_Antenna) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Antenna != 0 {
		n += 1 + sovRouter(uint64(m.Antenna))
	}
	if m.Channel != 0 {
		n += 1 + sovRouter(uint64(m.Channel))
	}
	if m.Rssi != 0 {
		n += 5
	}
	if m.Snr != 0 {
		n += 5
	}
	if m.ChannelRssi != 0 {
		n += 5
	}
	if m.RssiStandardDeviation != 0 {
		n += 5
	}
	if m.FrequencyOffset != 0 {
		n += 1 + sovRouter(uint64(m.FrequencyOffset))
	}
	l = len(m.EncryptedTime)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	if m.FineTime != 0 {
		n += 1 + sovRouter(uint64(m.FineTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GatewayTxConfiguration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovRouter(uint64(m.Timestamp))
	}
	if m.RfChain != 0 {
		n += 2 + sovRouter(uint64(m.RfChain))
	}
	if m.Frequency != 0 {
		n += 2 + sovRouter(uint64(m.Frequency))
	}
	if m.Power != 0 {
		n += 2 + sovRouter(uint64(m.Power))
	}
	if m.PolarizationInversion {
		n += 3
	}
	if m.FrequencyDeviation != 0 {
		n += 2 + sovRouter(uint64(m.FrequencyDeviation))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovRouter(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovRouter(uint64(m.Time))
	}
	if m.GatewayTrusted {
		n += 2
	}
	if m.BootTime != 0 {
		n += 1 + sovRouter(uint64(m.BootTime))
	}
	if len(m.Ip) > 0 {
		for _, s := range m.Ip {
			l = len(s)
			n += 1 + l + sovRouter(uint64(l))
		}
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	l = len(m.ContactEmail)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	l = len(m.FrequencyPlan)
	if l > 0 {
		n += 1 + l + sovRouter(uint64(l))
	}
	l = len(m.Bridge)
	if l > 0 {
		n += 2 + l + sovRouter(uint64(l))
	}
	l = len(m.Router)
	if l > 0 {
		n += 2 + l + sovRouter(uint64(l))
	}
	if m.Fpga != 0 {
		n += 2 + sovRouter(uint64(m.Fpga))
	}
	if m.Dsp != 0 {
		n += 2 + sovRouter(uint64(m.Dsp))
	}
	l = len(m.Hal)
	if l > 0 {
		n += 2 + l + sovRouter(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 2 + l + sovRouter(uint64(l))
	}
	if m.Rtt != 0 {
		n += 2 + sovRouter(uint64(m.Rtt))
	}
	if m.RxIn != 0 {
		n += 2 + sovRouter(uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		n += 2 + sovRouter(uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		n += 2 + sovRouter(uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		n += 2 + sovRouter(uint64(m.TxOk))
	}
	if m.LmOk != 0 {
		n += 2 + sovRouter(uint64(m.LmOk))
	}
	if m.LmSt != 0 {
		n += 2 + sovRouter(uint64(m.LmSt))
	}
	if m.LmNw != 0 {
		n += 2 + sovRouter(uint64(m.LmNw))
	}
	if m.LPps != 0 {
		n += 2 + sovRouter(uint64(m.LPps))
	}
	if m.Os != nil {
		l = m.Os.Size()
		n += 2 + l + sovRouter(uint64(l))
	}
	if len(m.Messages) > 0 {
		for _, s := range m.Messages {
			l = len(s)
			n += 2 + l + sovRouter(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StatusMessage_OSMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Load_1 != 0 {
		n += 5
	}
	if m.Load_5 != 0 {
		n += 5
	}
	if m.Load_15 != 0 {
		n += 5
	}
	if m.CpuPercentage != 0 {
		n += 5
	}
	if m.MemoryPercentage != 0 {
		n += 6
	}
	if m.Temperature != 0 {
		n += 6
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRouter(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRouter(x uint64) (n int) {
	return sovRouter(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UplinkMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UplinkMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UplinkMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolMetadata == nil {
				m.ProtocolMetadata = &ProtocolRxMetadata{}
			}
			if err := m.ProtocolMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GatewayMetadata == nil {
				m.GatewayMetadata = &GatewayRxMetadata{}
			}
			if err := m.GatewayMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trace == nil {
				m.Trace = &Trace{}
			}
			if err := m.Trace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownlinkMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownlinkMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownlinkMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProtocolConfiguration == nil {
				m.ProtocolConfiguration = &ProtocolTxConfiguration{}
			}
			if err := m.ProtocolConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GatewayConfiguration == nil {
				m.GatewayConfiguration = &GatewayTxConfiguration{}
			}
			if err := m.GatewayConfiguration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trace == nil {
				m.Trace = &Trace{}
			}
			if err := m.Trace.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Event = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRouter
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRouter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRouter
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRouter
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRouter
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRouter
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRouter
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRouter(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRouter
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parents = append(m.Parents, &Trace{})
			if err := m.Parents[len(m.Parents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolRxMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolRxMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolRxMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lorawan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lorawan == nil {
				m.Lorawan = &LoRaWANMetadata{}
			}
			if err := m.Lorawan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolTxConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolTxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolTxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lorawan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lorawan == nil {
				m.Lorawan = &LoRaWANTxConfiguration{}
			}
			if err := m.Lorawan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoRaWANMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoRaWANMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoRaWANMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modulation", wireType)
			}
			m.Modulation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modulation |= Modulation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitRate", wireType)
			}
			m.BitRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BitRate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodingRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodingRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FCnt", wireType)
			}
			m.FCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyPlan", wireType)
			}
			m.FrequencyPlan = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyPlan |= FrequencyPlan(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoRaWANTxConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoRaWANTxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoRaWANTxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Modulation", wireType)
			}
			m.Modulation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Modulation |= Modulation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BitRate", wireType)
			}
			m.BitRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BitRate |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodingRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodingRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FCnt", wireType)
			}
			m.FCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FCnt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocationMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocationMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocationMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Latitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Longitude = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			m.Altitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Altitude |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accuracy", wireType)
			}
			m.Accuracy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Accuracy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= LocationMetadata_LocationSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayRxMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayRxMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayRxMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GatewayTrusted = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTime", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTime = append(m.EncryptedTime[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTime == nil {
				m.EncryptedTime = []byte{}
			}
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfChain", wireType)
			}
			m.RfChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfChain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Antennas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Antennas = append(m.Antennas, &GatewayRxMetadata_Antenna{})
			if err := m.Antennas[len(m.Antennas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rssi = float32(math.Float32frombits(v))
		case 33:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Snr = float32(math.Float32frombits(v))
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &LocationMetadata{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayRxMetadata_Antenna) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Antenna: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Antenna: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Antenna", wireType)
			}
			m.Antenna = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Antenna |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Rssi = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Snr = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelRssi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ChannelRssi = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RssiStandardDeviation", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RssiStandardDeviation = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyOffset", wireType)
			}
			m.FrequencyOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedTime", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedTime = append(m.EncryptedTime[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedTime == nil {
				m.EncryptedTime = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FineTime", wireType)
			}
			m.FineTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FineTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayTxConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayTxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayTxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfChain", wireType)
			}
			m.RfChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfChain |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolarizationInversion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PolarizationInversion = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyDeviation", wireType)
			}
			m.FrequencyDeviation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyDeviation |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GatewayTrusted = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootTime", wireType)
			}
			m.BootTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BootTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = append(m.Ip, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyPlan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FrequencyPlan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bridge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Router = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fpga", wireType)
			}
			m.Fpga = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fpga |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dsp", wireType)
			}
			m.Dsp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dsp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &LocationMetadata{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxIn", wireType)
			}
			m.RxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxOk", wireType)
			}
			m.RxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxOk |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			m.TxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxIn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOk", wireType)
			}
			m.TxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxOk |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmOk", wireType)
			}
			m.LmOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LmOk |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmSt", wireType)
			}
			m.LmSt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LmSt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LmNw", wireType)
			}
			m.LmNw = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LmNw |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LPps", wireType)
			}
			m.LPps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LPps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &StatusMessage_OSMetrics{}
			}
			if err := m.Os.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 52:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRouter
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRouter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusMessage_OSMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Load_1 = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_5", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Load_5 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_15", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Load_15 = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CpuPercentage = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MemoryPercentage = float32(math.Float32frombits(v))
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Temperature = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRouter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRouter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRouter(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRouter
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRouter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRouter
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRouter
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRouter
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRouter        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRouter          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRouter = fmt.Errorf("proto: unexpected end of group")
)
